input {
  stdin {
    type => "ezproxylog"
    debug => true
  }
  file {
    debug => true
    discover_interval => 1
    path => [ "/Users/jstirnaman/development/ezproxy/logs/ezproxy_sample.log" ]
    sincedb_path => "/Users/jstirnaman/development/logstash/.sincedb"    
    start_position => "beginning"
    type => "ezproxylog"    
  }
}

filter {
  grok {
    type => "ezproxylog"
    # Default EZproxy LogFormat command:
    # LogFormat %h %l %u %t "%r" %s %b
    # Where:
    #  h = Host accessing EZproxy (always IP address).
    #  l = Remote username obtained by idented (identd is not used, so this always inserts -).
    #  u = Username or Session Identifier
    #  t = Date/time of request. Can appear as %{format}
    #  r = Complete request
    #  s = HTTP numeric status code
    #  b = Number of bytes transferred
    pattern => "%{WORD:ezproxy_logformat} %{IP:request_client_ip} %{USERNAME:request_remote_username} %{USERNAME:request_username} \[%{HTTPDATE:request_timestamp}\] %{QUOTEDSTRING:request_raw} %{NUMBER:response_http} %{NUMBER:response_bytes} \"%{URI:requested_uri}\""
  }
  date {
    type => "ezproxylog"
    # Try to set the @timestamp field from the 'request_timestamp' field (parsed above with
    # grok).
    match => [ "request_timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
  }
   geoip {
     type => "ezproxylog"
     # Try to get GeoIP lookup using value from the 'request_client_ip' field (parsed above with
     # grok).
     source => "request_client_ip"
   }
  grok {
    # Add field requested_host to the output, matching on URIHOST from requested_uri field.
    type => "ezproxylog"
    match => [ "requested_uri", "%{URIPROTO}://(?:%{USER}(?::[^@]*)?@)?(?:%{URIHOST:requested_host})?(?:%{URIPATHPARAM})?" ]
  }
  grok {
    # If client IP is internal, map it to the building name. Each building has a unique value in the second octet of the IP.
    type => "ezproxylog"
    patterns_dir => [ "/Users/jstirnaman/development/logstash/patterns" ]
    match => [ "request_client_ip", "%{IPINTERNAL}.*" ]
    add_tag => [ "internal_requests" ]
    remove_tag => [ "_grokparsefailure" ] 
  }
  grok {
    # If client IP is internal, map it to the building name. Each building has a unique value in the second octet of the IP.
    type => "ezproxylog"
    tags => [ "internal_requests" ]
    patterns_dir => [ "/Users/jstirnaman/development/logstash/patterns" ]
    match => [ "request_client_ip", "%{IPOCTET}\.%{IPOCTET:request_building}\..*" ]
    remove_tag => [ "_grokparsefailure" ]
  } 
  translate {
    # If request is internal then translate IP second octet to building name 
    tags => [ "internal_requests" ]
    dictionary_path => [ "dictionaries/kumc_building_ip.yml" ]
    destination => "request_building"
    field => "request_building"
  }
  mutate {
    type => "ezproxylog"
    replace => [ "@message", "%{request_raw}" ]
}
}

output {
  stdout {
    type => "ezproxylog"
    debug => true
    message => "%{@message}"
  }
  elasticsearch_river {
    rabbitmq_host => "localhost"
    es_host => "localhost"
    key => "logstash.ezproxy" 
  }
}
